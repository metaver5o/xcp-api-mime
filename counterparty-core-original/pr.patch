From 5107880a19b48a4c2fc35f6ad656a9aa85927bef Mon Sep 17 00:00:00 2001
From: Antoine De Vuyst <fortyonepointsix@gmail.com>
Date: Wed, 28 Jan 2026 13:28:06 -0500
Subject: [PATCH] Update helpers.py

support MIME types with parameters for ordinal inscriptions.

e.g. audio/ogg;codecs=opus
not just audio/ogg;

Fix validation to support MIME types with codec paramters (
e.g. audio/ogg;codecs=opus)  when creating ordinal inscriptions with counterparty tokens via API.






Signed-off-by: Antoine De Vuyst <fortyonepointsix@gmail.com>
---
 .../counterpartycore/lib/utils/helpers.py         | 15 ++++++++++-----
 1 file changed, 10 insertions(+), 5 deletions(-)

diff --git a/counterparty-core/counterpartycore/lib/utils/helpers.py b/counterparty-core/counterpartycore/lib/utils/helpers.py
index 7529cbf660..6c8d2612cb 100644
--- a/counterparty-core/counterpartycore/lib/utils/helpers.py
+++ b/counterparty-core/counterpartycore/lib/utils/helpers.py
@@ -171,16 +171,19 @@ def get_current_commit_hash(not_from_env=False):
 
 
 def classify_mime_type(mime_type):
+    # Extract base MIME type (remove parameters like codecs)
+    base_mime_type = mime_type.split(";")[0].strip()
+    
     # Types that start with "text/" are textual
     if (
-        mime_type.startswith("text/")
-        or mime_type.startswith("message/")
-        or mime_type.endswith("+xml")
+        base_mime_type.startswith("text/")
+        or base_mime_type.startswith("message/")
+        or base_mime_type.endswith("+xml")
     ):
         return "text"
 
     # List of application types that are textual
-    if mime_type in [
+    if base_mime_type in [
         "application/xml",
         "application/javascript",
         "application/json",
@@ -214,7 +217,9 @@ def bytes_to_content(content: bytes, mime_type: str) -> str:
 def check_content(mime_type, content):
     problems = []
     content_mime_type = mime_type or "text/plain"
-    if content_mime_type not in mimetypes.types_map.values():
+    # Extract base MIME type (remove parameters like codecs)
+    base_mime_type = content_mime_type.split(";")[0].strip()
+    if base_mime_type not in mimetypes.types_map.values():
         problems.append(f"Invalid mime type: {mime_type}")
     try:
         content_to_bytes(content, content_mime_type)
